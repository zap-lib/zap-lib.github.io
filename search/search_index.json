{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Zap: A library for building multi-device applications","text":"<p>Zap is an application programming library for building multi-device application that enable communication with other devices. While mobile devices offer a wide range of data sources, such as motion sensors, biometrics devices, microphones, touchscreens and more, traditional PCs like laptops and desktops are typically lack these resources.</p> <p>The data sources available on mobile devices are valuable, but are often device-dependent, limiting their widespread use. Imagine if PCs could use the series of data from the accelerometer sensor on a mobile device. A simple example is using smartphone as motion controller for PC.</p> <p>In the video above, a smartphone served as a motion controller for the driving game 'slow roads' running on laptop. The smartphone's accelerometer sensor transmitted the measured values to the laptop via Zap client, where the laptop received these values through Zap server. Subsequently, the server triggers a specific keys(in this case, 'A' and 'D' keys) based on the values and their corresponding thresholds.</p> <p>Of course, it can also become a simple remote controller, not a motion controller. The following video demonstrates using a smartphone as a presentation remote clicker.</p> <p>To overcome the limitation that data sources are confined to a single mobile device, Zap provides its own network protocol and programming interface to access data sources on other devices. Please check the Architectures section for more information about Zap's communication specification and structure.</p> <p></p> <p>In the following application code blocks, it shows that the client instance on an Android device sends acceleration force data to the server device.</p> <pre><code>class MainActivity: AppCompatActivity(), SensorEventListener {\n  private lateinit var zap: ZapClient\n\n  override fun onCreate(state: Bundle?) {\n    // Create a new Zap client with the server's IP address.\n    zap = ZapClient(InetAddress.getByName(...))\n  }\n\n  // Define the method that is invoked whenever\n  // any sensors on the local device have changed.\n  override fun onSensorChanged(event: SensorEvent) {\n    if (event.sensor.type == Sensor.TYPE_ACCELEROMETER) {\n      val (x, y, z) = event.values\n      // Send the data acquired from the accelerometer to the server.\n      zap.send(ZapAccelerometer(x, y, z))\n    }\n  }\n}\n</code></pre> <p>Currently, Zap does not provide a built-in methods for obtaining the server's IP address. To identify the server device's address, you may consider alternative way such as using QR code to share the server's address or communicating via protocols like NFC or BLE.</p> <p>On the server device, the server instance can retrieve the data from accelerometer sensor on the client device. In this example, TypeScript code is executed on the Node.js runtime on a desktop.</p> <pre><code>// Create and start a new Zap server to listen for data from clients.\n(new class extends ZapServer {\n  // Define the method that is called whenever accelerometer sensor data is\n  // received from client devices.\n  onAccelerometerReceived(info: MetaInfo, data: ZapAccelerometer) {\n    console.log(`Data received from ${info.dgram.address}:\n      (${data.x}, ${data.y}, ${data.z})`);\n  }\n}).listen();\n</code></pre> <p>The main goal of Zap is to support mobile-PC communication, but it also extends its capabilities to enable mobile-mobile and PC-PC communication. Furthermore, it's not limited to PCs; any devices capable of running Zap implementations(e.g., Kiosk device, Smart TV, etc.) can also participate in this communication.</p> <p>What kind of awesome applications can we build by extending the boundaries of data sources with Zap? Here are a some example applications:</p> <ul> <li>Motion controller: An example of turning a mobile device into a remote game controller. This controller features motion sensing capabilities, which determine the device's orientation through an accelerometer sensor. The server, running on a PC, receives data from the controller and maps it to specific keys on the keyboard.</li> <li>Digital ink: An example that assists in obtaining text from handwritten notes made on a mobile device's touchscreen on a PC.</li> </ul> <p>See more examples on zap-lib/examples repository.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Let's explore step-by-step how to create a multi-device application using Zap. In this example, we'll use the Zap Kotlin implementation on Android to real-time transmit accelerometer sensor values from a mobile device to a Zap Node.js implementation running on a laptop.</p>"},{"location":"getting-started/#server","title":"Server","text":"<p>Let's first create a server that will receive accelerometer sensor values from the client. The server will run on the laptop. Simply create an npm project, and after that (you can use yarn or pnpm if you prefer), install <code>zap-lib-js</code>.</p> <pre><code>$ mkdir my-zap-server\n$ cd my-zap-server\n$ npm init\n$ npm install zap-lib-js\n</code></pre> <p>Now, simply create an index.js file and write the Zap server. This server will receive accelerometer sensor values measured based on the x, y, z axes from the client and print them to the console each time it receives the values.</p> <pre><code>import { ZapServer } from 'zap-lib-js';\n\n(new class extends ZapServer {\n  onAccelerometerReceived(info, data) {\n    console.log(`Data received from ${info.dgram.address}: (${data.x}, ${data.y}, ${data.z})`);\n  }\n}).listen();\n</code></pre> <p>It's surprisingly simple. Now, if you run <code>index.js</code> using <code>node</code>, the server will be up and listening.</p> <pre><code>$ node index.js\n</code></pre>"},{"location":"getting-started/#client","title":"Client","text":"<p>Now that we've created the server, let's create the client. Let's consider the client to be running on an Android mobile device.</p> <p>Create an Android project based on an empty activity, and then add dependency. Since Zap is distributed through JitPack, you need to first add the JitPack repository to the <code>settings.gradle</code> file.</p> <pre><code>dependencyResolutionManagement {\n  repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\n  repositories {\n    google()\n    mavenCentral()\n    maven { url 'https://jitpack.io' }\n  }\n}\n</code></pre> <p>Next, add the dependency to the <code>build.gradle</code> file. Replace <code>$VERSION</code> with your desired version. For example, if you want to use version v0.1.0, input <code>0.1.0</code>.</p> <pre><code>dependencies {\n  // ...\n  implementation 'com.github.zap-lib:kotlin:$VERSION'\n}\n</code></pre> <p>Now, in the <code>MainActivity.kt</code> file, define the callback function that is called every time the accelerometer sensor embedded in the device measures a new value. For now, let's just output the measured x, y, z values using Logcat.</p> <pre><code>class MainActivity: AppCompatActivity(), SensorEventListener {\n  private lateinit var sensorManager: SensorManager\n\n  override fun onCreate(state: Bundle?) {\n    super.onCreate(state)\n    setContentView(R.layout.activity_main)\n\n    sensorManager = getSystemService(Context.SENSOR_SERVICE) as SensorManager\n  }\n\n  override fun onSensorChanged(event: SensorEvent) {\n    if (event.sensor.type == Sensor.TYPE_ACCELEROMETER) {\n      val (x, y, z) = event.values\n      Log.i(this::class.java.simpleName, \"$x, $y, $z\")\n    }\n  }\n\n  override fun onAccuracyChanged(p0: Sensor?, p1: Int) {}\n\n  override fun onStart() {\n    super.onStart()\n    sensorManager.registerListener(this,\n      sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER),\n      SensorManager.SENSOR_DELAY_GAME)\n    }\n\n  override fun onStop() {\n    super.onStop()\n    sensorManager.unregisterListener(this)\n  }\n}\n</code></pre> <p>In this state, when you build and run the application, the values measured based on the x, y, z axes will be logged every time the device is tilted. Now, let's send the values to the server using Zap. Since Zap communicates through UDP socket, you need to add <code>INTERNET</code> permission to the <code>AndroidManifest.xml</code> file first.</p> <pre><code>&lt;?xml ...&gt;\n&lt;manifest ...&gt;\n    &lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt;\n    &lt;application ...&gt;\n      &lt;activity ... /&gt;\n    &lt;/application&gt;\n&lt;/manifest&gt;\n</code></pre> <p>Sending data using Zap is really easy. You just need to add a few lines to the code written above.</p> <pre><code>class MainActivity: AppCompatActivity(), SensorEventListener {\n  private lateinit var sensorManager: SensorManager\n  private lateinit var zap: ZapClient\n\n  override fun onCreate(state: Bundle?) {\n    super.onCreate(state)\n    setContentView(R.layout.activity_main)\n\n    sensorManager = getSystemService(Context.SENSOR_SERVICE) as SensorManager\n    zap = ZapClient(InetAddress.getByName(\"192.168.0.1\"))\n  }\n\n  override fun onSensorChanged(event: SensorEvent) {\n    if (event.sensor.type == Sensor.TYPE_ACCELEROMETER) {\n      val (x, y, z) = event.values\n      Log.i(this::class.java.simpleName, \"$x, $y, $z\")\n      zap.send(ZapAccelerometer(x, y, z))\n    }\n  }\n\n  override fun onAccuracyChanged(p0: Sensor?, p1: Int) {}\n\n  override fun onStart() {\n    super.onStart()\n    sensorManager.registerListener(this,\n      sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER),\n      SensorManager.SENSOR_DELAY_GAME)\n    }\n\n  override fun onStop() {\n    super.onStop()\n    sensorManager.unregisterListener(this)\n    zap.stop()\n  }\n}\n</code></pre> <p>Now, if you tilt the client device, you should see numerous values being continuously printed in the console of the server device.</p> <p>Note that when creating a <code>ZapClient</code> instance, the server's IP address is passed as a constant value. Here, <code>192.168.0.1</code> is the local IP address of the laptop where the server, written earlier, is running. In this example, the client and server are on the same network, so a local IP can be used. If the server device has its public IP, it does not necessarily need to be connected to the same network.</p> <p>You might find it unreasonable to write the server's IP address as a constant. There are various ways to dynamically determine the server's IP address, but typically, you can consider the following methods:</p> <ul> <li>NFC: Place the client device close to the server device to receive the server's IP address.</li> <li>Bluetooth: Pair the server device and the client device to obtain the server's IP address.</li> <li>QR: The server device provides a QR code containing its IP address on a monitor, and the client device can scan it to obtain the address.</li> </ul> <p>You can check the example application in the examples repository for the QR method.</p>"},{"location":"implementations/","title":"Implementations","text":"<ul> <li>Node.js: github.com/zap-lib/node</li> <li>Kotlin: github.com/zap-lib/kotlin</li> </ul>"},{"location":"architectures/","title":"Architectures","text":"<p>Zap is structured as a client-server model. The client unidirectionally sends data, and the server receives and processes it. This architecture keeps Zap's design simple and naturally allows a 1:N structure where multiple clients can send data to a single server.</p> <p></p> <p>A data sent from the client to the server is transmitted over UDP socket. Zap is implemented to send this data by defining 'ZAPP Object' defined on top of datagram, which contain the timestamp, resource type, and the actual data. ZAPP Object is the data unit of ZAPP(Zap Protocol), for more detailed information about the protocol, please check the ZAPP page.</p> <p>Zap uses callback functions to enable the transformation of a single-device application into a multi-device application while maintaining its own structure. The client, after obtaining the data they wish to transmit through the data source access API provided by their development framework, simply needs to call <code>zap.send(...)</code>. The server, running a Zap server instance, only needs to define callback functions to specify what code to execute each time it receives data from the client.</p>"},{"location":"architectures/project-structures/","title":"Project Structures","text":"<p>The project structure is straightforward. Under the root, there are four main modules: <code>ZapClient</code>, <code>ZapServer</code>, <code>Models</code>, and <code>Resources</code>.</p> <p></p> <p><code>Models</code> include interfaces and type definitions generally referenced throughout the Zap system. On the other hand, <code>Resources</code> consist of implementations of <code>Zapable</code> that can be transmitted via Zap. For example, <code>ZapAccelerometer</code> is a <code>Zapable</code> implementation representing accelerometer data. These resource implementations are referenced to abstract the data obtained from data sources in <code>ZapClient</code> or <code>ZapServer</code> and are encapsulated in <code>ZappObject</code> for network transmission. For more detailed information on each component, please read the Specifications section.</p>"},{"location":"architectures/zap-protocol/","title":"ZAPP (Zap Protocol)","text":"<p>Zap defines a new network protocol over UDP to facilitate data exchange in an agreed-upon format across various platforms. This protocol is referred to as ZAPP(Zap Protocol), and the ZAPP data contained in a single datagram is called a 'ZAPP Object'.</p> <p>The ZAPP Object is divided into two main parts: the header and the payload. The header contains metadata about the ZAPP Object, while the payload represents the actual data of interest to the communicating parties.</p> <p></p> <p>The header consists of a timestamp and a resource field. The first 64 bits of the header constitute the timestamp field, representing the epoch time in milliseconds when the ZAPP Object was created. As UDP does not guarantee the order of datagrams, this field can be utilized if the order of data is crucial. This field can be interpreted as an unsigned integer.</p> <p>Following the timestamp, the next 8 bits constitute the resource field. The resource field informs which resource the payload represents and simultaneously implies how the payload is encoded. This field can be interpreted as an unsigned integer.</p> <p>After the 72-bit header, there is the payload part. The format of the payload varies depending on the resource. It can be a simple primitive type, text with delimiters, or JSON. For example, the payload of acceleration data is encoded with values measured along the x, y, and z axes, each taking up 32 bits, totaling 96 bits.</p> <p></p> <p>Refer to the Resources page for information on the payload format each resource takes. The maximum length of the payload is theoretically up to 65,518 bytes, although it may vary depending on the implementation of Zap server.</p>"},{"location":"specifications/","title":"Specifications","text":"<p>Zap aims to support various programming languages and runtimes. Therefore, there is a need to provide a consistent interface across all implementations. This section defines the standard interfaces of Zap.</p> <p>This specification defines a general interface for implementations and is not based on any specific programming language. Therefore, please refer to the API documentation of each implementation for details such as specific function names, property names, and parameters.</p> <p>Among the interfaces presented in this specification, there are those that must be implemented, those that are recommended for implementation under specific circumstances, and optional ones. In such cases, keywords are used in accordance with the criteria suggested in RFC 2119.</p>"},{"location":"specifications/client-and-server/","title":"Client and Server","text":""},{"location":"specifications/client-and-server/#zapclient","title":"<code>ZapClient</code>","text":"<p>A client sends data to server.</p> type signature description property <code>server_address</code> An IP address of the device running <code>ZapServer</code>. function <code>send(obj: Zapable): void</code> Send given <code>Zapable</code> object to the server.  <code>obj</code>: An object to send. function <code>stop(): void</code> Close the socket."},{"location":"specifications/client-and-server/#zapserver","title":"<code>ZapServer</code>","text":"<p>A server receives data from client. The 'open function' refers to a callback function that users SHOULD override when declaring a ZapServer object to define its behavior. Refer to the Resources section for information on the parameters of each open function.</p> type signature description function <code>listen(port: int): void</code> Start listening the transmitted data from clients on the given port.  <code>port</code>: A port number for receiving data (default: <code>65500</code>). function <code>stop(): void</code> Stop listening to clients. open function <code>onAccelerometerReceived(info: MetaInfo, data: ZapAccelerometer): void</code> A callback function called whenever accelerometer sensor data is received. open function <code>onGeoPointReceived(info: MetaInfo, data: ZapGeoPoint): void</code> A callback function called whenever geological point is received. open function <code>onGravityReceived(info: MetaInfo, data: ZapGravity): void</code> A callback function called whenever gravity data is received. open function <code>onGyroscopeReceived(info: MetaInfo, data: ZapGyroscope): void</code> A callback function called whenever gyroscope data is received. open function <code>onIlluminanceReceived(info: MetaInfo, data: ZapIlluminance): void</code> A callback function called whenever illuminance data is received. open function <code>onMagneticFieldReceived(info: MetaInfo, data: ZapMagneticField): void</code> A callback function called whenever magnetic field data is received. open function <code>onUIEventReceived(info: MetaInfo, data: ZapUiEvent): void</code> A callback function called whenever UI event data is received. open function <code>onTextReceived(info: MetaInfo, data: ZapText): void</code> A callback function called whenever text data is received. <p>The server implementation, upon receiving a datagram, MUST reference the <code>ZappHeader</code> to identify the resource and then invoke the corresponding callback function for that resource. For detailed specifications on supported resources, please refer to Resources section.</p> <p>It is RECOMMENDED to implement throwing a \"Not yet implemented\" exception if the callback function is not defined and the corresponding resource data is received.</p>"},{"location":"specifications/client-and-server/#metainfo","title":"<code>MetaInfo</code>","text":"type signature description property <code>header: ZappHeader</code> ZAPP header object. property <code>dgram</code> A framework-specific type that contains datagram information such as address and port."},{"location":"specifications/models/","title":"Models","text":"<p>In this section, the term 'bytes' is used to refer to a type representing a sequence of bytes, such as <code>Buffer</code> in Node.js and <code>ByteBuffer</code> in Java/Kotlin.</p>"},{"location":"specifications/models/#zappobject","title":"<code>ZappObject</code>","text":"<p>An object that represents the encoded bytes on a single datagram.</p> <p>ZAPP(Zap Protocol) is network protocol defined on the top of UDP datagram for client and server to exchange 'Zapable' data. For more information about the protocol, read ZAPP page.</p> type signature description property <code>header: ZappHeader</code> A header part. property <code>payload: ZappPayload</code> A payload part. function <code>toBytes(): bytes</code> Encode <code>ZappObject</code> to bytes. The sequence of bytes is MUST encoded as ZAPP Object. static function <code>from(b: bytes): ZappObject</code> Decode the given bytes in received datagram to <code>ZapObject</code>.  <code>b</code>: A sequence of bytes to convert that MUST be encoded as ZAPP Object."},{"location":"specifications/models/#zappheader","title":"<code>ZappHeader</code>","text":"type signature description property <code>timestamp: 64_bit_uint</code> An epoch time in milliseconds for creation time of <code>ZappObject</code>. (default: Current epoch) property <code>resource: ZapResource</code> A resource type of the payload. It indicates a format of payload. function <code>writeTo(b: bytes): bytes</code> Write <code>ZappHeader</code> to given <code>b</code> and return it. The given <code>b</code> MUST be encoded as ZAPP Header. static function <code>from(b: bytes): ZappHeader</code> Read bytes from the given <code>b</code> and decode it to <code>ZappHeader</code>."},{"location":"specifications/models/#zapppayload","title":"<code>ZappPayload</code>","text":"<p>A typealias for bytes.</p>"},{"location":"specifications/models/#interface-zapable","title":"<code>interface Zapable</code>","text":"<p>An interface for data exchange through Zap. Data objects exchanged via Zap MUST implement this interface. If an object can be transmitted through Zap, it can be referred to as \"Zapable\".</p> type signature description property <code>resource: ZapResource</code> A resource type of the object. function <code>toPayload(): ZappPayload</code> Encode <code>Zapable</code> to <code>ZappPayload</code> and return it. static function <code>from(payload: ZappPayload): Zapable</code> Decode and return <code>Zapable</code> object from <code>ZappPayload</code>. If possible, it is RECOMMENDED to separate it into <code>interface DeZapable</code> to enforce implementation.  <code>payload</code>: A payload to decode to <code>Zapable</code> object."},{"location":"specifications/resources/","title":"Resources","text":""},{"location":"specifications/resources/#enum-zapresource","title":"<code>enum ZapResource</code>","text":"<p>A registry of resources supported by Zap and their identification keys.</p> property key(8-bit uint) type <code>ACCELEROMETER</code> 10 <code>ZapAccelerometer</code> <code>GRAVITY</code> 11 <code>ZapGravity</code> <code>GYROSCOPE</code> 12 <code>ZapGyroscope</code> <code>ILLUMINANCE</code> 13 <code>ZapIlluminance</code> <code>MAGNETIC_FIELD</code> 14 <code>ZapMagneticField</code> <code>UI_EVENT</code> 20 <code>ZapUiEvent</code> <code>TEXT</code> 30 <code>ZapText</code> <code>GEO_POINT</code> 31 <code>ZapGeoPoint</code>"},{"location":"specifications/resources/#zapaccelerometer","title":"<code>ZapAccelerometer</code>","text":"<p>Represent values measured by accelerometer sensor</p> <pre><code>+-------------+-------------+-------------+\n| x (32 bits) | y (32 bits) | z (32 bits) |\n+-------------+-------------+-------------+\n</code></pre> type signature description property <code>x: float</code> Acceleration force along the x axis. (m/s\u00b2) property <code>y: float</code> Acceleration force along the y axis. (m/s\u00b2) property <code>z: float</code> Acceleration force along the z axis. (m/s\u00b2)"},{"location":"specifications/resources/#zapgravity","title":"<code>ZapGravity</code>","text":"<p>Represent the force of gravity that is applied to a device.</p> <pre><code>+-------------+-------------+-------------+\n| x (32 bits) | y (32 bits) | z (32 bits) |\n+-------------+-------------+-------------+\n</code></pre> type signature description property <code>x: float</code> Force of gravity along the x axis. (m/s\u00b2) property <code>y: float</code> Force of gravity along the y axis. (m/s\u00b2) property <code>z: float</code> Force of gravity along the z axis. (m/s\u00b2)"},{"location":"specifications/resources/#zapgyroscope","title":"<code>ZapGyroscope</code>","text":"<p>Represent a device's rate of rotation.</p> <pre><code>+-------------+-------------+-------------+\n| x (32 bits) | y (32 bits) | z (32 bits) |\n+-------------+-------------+-------------+\n</code></pre> type signature description property <code>x: float</code> Rate of rotation around the x axis. (rad/s) property <code>y: float</code> Rate of rotation around the y axis. (rad/s) property <code>z: float</code> Rate of rotation around the z axis. (rad/s)"},{"location":"specifications/resources/#zapilluminance","title":"<code>ZapIlluminance</code>","text":"<p>Represent the ambient light level.</p> <pre><code>+--------------+\n| lx (32 bits) |\n+--------------+\n</code></pre> type signature description property <code>lx: float</code> Ambient light level. (lx)"},{"location":"specifications/resources/#zapmagneticfield","title":"<code>ZapMagneticField</code>","text":"<p>Represent a ambient geomagnetic field.</p> <pre><code>+-------------+-------------+-------------+\n| x (32 bits) | y (32 bits) | z (32 bits) |\n+-------------+-------------+-------------+\n</code></pre> type signature description property <code>x: float</code> Geomagnetic field strength along the x axis. (\u03bcT) property <code>y: float</code> Geomagnetic field strength along the y axis. (\u03bcT) property <code>z: float</code> Geomagnetic field strength along the z axis. (\u03bcT)"},{"location":"specifications/resources/#zapuievent","title":"<code>ZapUiEvent</code>","text":"<p>Represent data related to event raised by the user interface.</p> type signature description property <code>ui_id: string</code> An identifier for the UI. property <code>event: ZapUiEvent.Event</code> A type of event occurring for the UI. property <code>value: string?</code> A value changed due to the event. (optional)"},{"location":"specifications/resources/#event","title":"<code>Event</code>","text":"property value description <code>CLICK</code> <code>CLICK</code> An event triggered when a click (or touch) on the UI begins and ends within a short period. <code>CLICK_DOWN</code> <code>CLICK_DOWN</code> An event triggered when a click (or touch) is initiated on the UI. <code>CLICK_UP</code> <code>CLICK_UP</code> An event triggered when a click (or touch) on the UI has ended."},{"location":"specifications/resources/#zaptext","title":"<code>ZapText</code>","text":"<p>Represent simple text.</p> <pre><code>+------------------+--------------+\n| charset (8 bits) | str (n bits) |\n+------------------+--------------+\n</code></pre> type signature description property <code>str: string</code> Just string. property <code>charset: ZapCharset</code> A character set of <code>str</code>. (default: UTF-8)"},{"location":"specifications/resources/#zapcharset","title":"<code>ZapCharset</code>","text":"<p>The character sets.</p> <p>Some platforms may support only the limited character sets. In such cases, it is RECOMMENDED to either enforce the use of the different character sets or consider it as an error.</p> property key(8-bit uint) UTF_8 0 UTF_16 1 UTF_16BE 2 UTF_16LE 3 UTF_32 4 UTF_32BE 5 UTF_32LE 6 ISO_8859_1 7 US_ASCII 8"},{"location":"specifications/resources/#zapgeopoint","title":"<code>ZapGeoPoint</code>","text":"<p>Represent a point on earth in geological coordinates.</p> <pre><code>+--------------------+---------------------+\n| latitude (64 bits) | longitude (64 bits) |\n+--------------------+---------------------+\n</code></pre> type signature description property <code>latitude: double</code> A latitude of the point. property <code>longitude: double</code> A longitude of the point."}]}